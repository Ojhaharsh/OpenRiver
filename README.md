# Open Source River Solver

A high-performance, vectorized Poker River Solver built in Python.

This tool calculates **Game Theory Optimal (GTO)** strategies for No-Limit Texas Hold'em river scenarios. It was built to address common issues with LLM-generated solvers by ensuring mathematical correctness (handling blockers/pot odds), high performance (vectorized NumPy engine), and a clean, interactive visualization.

## Features

* **Vectorized Engine:** Uses NumPy memory arrays to solve full 52-card deck scenarios at **~7,000 iterations/second** in pure Python (no C++ compilation required).
* **Dynamic Solving:** Input any board texture (e.g., `"Ah Ks Qh Jh Th"`) to rebuild the game tree and re-solve on the fly.
* **Interactive Analysis:** A heatmap visualization (`index.html`) to study GTO ranges, bluffing frequencies, and value betting.
* **Play vs Bot:** A real-time training mode (`play.html`) where you can play hands against the solution you just generated.
* **Correct Logic:** Properly handles card removal (blockers), pot odds, and polarized betting ranges.

## Installation

  **Install dependencies:**
    ```bash
    pip install -r requirements.txt
    ```
    *(Dependencies: `numpy`, `fastapi`, `uvicorn`, `treys`)*

## Quick Start

Run the backend server. This handles the heavy math and serves the API.
```bash
python main.py
```

*You will see `Uvicorn running on http://0.0.0.0:8000`.*

### Analyze Strategies (The Lab)

Open **`index.html`** in your web browser.

* **Input Board:** Type a board like `Ks Th 7s 4d 2s` in the text box.
* **Click Solve:** The engine will retrain for that specific board.
* **Study:** View the 13x4 grid to see exactly which hands to Bet (Red), Check/Call (Green), or Fold (Blue).

### Play Against the AI (The Arena)

Open **`play.html`** in your web browser.

* The game automatically loads the board and strategy you solved in step 2.
* **Play:** You will be dealt a hand (that doesn't conflict with the board).
* **Test:** Try to bluff the bot or catch its bluffs. The bot plays according to the GTO probabilities calculated by the engine.

⚠️ Important: If you solve a NEW board in index.html, you must refresh play.html to load the new strategy and board cards.
* Open index.html and solve a unique board, e.g., Ah Kh Qh Jh Th (All Hearts).
* Open play.html.
* Look at the Table: You should see A♥ K♥ Q♥ J♥ T♥ on the board.
* Look at the Deck: You should never be dealt a Heart (since they are all on the board).

## How It Works

### The Solver (Backend)
* **Game Logic:** The solver maps the 52-card deck into integer arrays. It pre-calculates a **Payoff Matrix** (52x52) using the `treys` evaluator to determine the winner of every possible showdown instantly.
* **Vectorized CFR:** Instead of traversing a tree of objects (slow), the algorithm performs matrix operations on flat `NumPy` arrays (fast). This allows it to simulate millions of poker hands in seconds.
* **API:** `main.py` uses `FastAPI` to expose endpoints. When you change the board, the server rebuilds the game object and retrains the model from scratch.

### The Bot (Frontend)
The bot in `play.html` is not random. It is connected directly to the solver's brain:
1.  **Fetch:** On load, it downloads the exact strategy matrix generated by `main.py`.
2.  **Lookup:** When it's the bot's turn, it looks up its specific hand (e.g., `Q♥`) in the strategy matrix.
3.  **Decision:** It uses the calculated probabilities (e.g., "Call 20%, Fold 80%") to make a weighted random decision.


## Credits

Built as an open-source improvement on existing lightweight river solvers, focusing on architectural modularity and vectorization speedups.
